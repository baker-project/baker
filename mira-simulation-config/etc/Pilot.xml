<root>
	<if_exists class="mira::pilot::VarResDynamicWindow">
		<var plannerClass="mira::pilot::VarResDynamicWindow" />
	</if_exists>
	<else>
		<var plannerClass="mira::pilot::DynamicWindow" />
	</else>
	<!--The used path planner-->
	<var pathPlanner="PathPlanner"/>

	<unit id="Pilot" class="mira::pilot::Pilot">
		<!--The interval of the watchdog-->
		<HeartbeatInterval>1000</HeartbeatInterval>
		<!--The interval for trying to recover-->
		<RecoverInterval>1000</RecoverInterval>
		<!--The cycle time of our process-->
		<CycleTime>250</CycleTime>
		<!--The maximum time about that we can exceed the cycle time before issuing a warning-->
		<CycleTimeTolerance>250</CycleTimeTolerance>
		<!--The name of the service that provides a robot model (if empty, a suitable service is chosen automatically)-->
		<ModelProvider></ModelProvider>
		<!--The name of the service that is used for setting the velocity (if empty, a suitable service is chosen automatically)-->
		<DriveService></DriveService>
		<!--The cpu usage in percent (default: 90%)-->
		<CPUUsage>60</CPUUsage>
		<!--If enabled, then the robot does not send drive commands-->
		<Mute>false</Mute>
		<!--Are recovery strategies enabled-->
		<UseRecovery>false</UseRecovery>
		<Planner class="$plannerClass">
			<!--Number of cells in translational velocity dimension (Only for DynamicWindow)-->
			<TransSize>20</TransSize>
			<!--Number of cells in rotational velocity dimension (Only for DynamicWindow)-->
			<RotSize>20</RotSize>
			<!--Velocity resolution in translational dimension (smallest grid cell size)-->
			<TransVelocityResolution>0.015</TransVelocityResolution>
			<!--Velocity resolution in rotational dimension (smallest grid cell size)-->
			<RotVelocityResolution>0.5</RotVelocityResolution>
			<!--the numbers (must be odd and > 2) describe how many cells per ring are inserted into the dynamic window moving from inner ring (0,0) to outer ring. The innermost ring has a fixed size of one cell-->
			<CellConfig>3 5 5 7 7 9 9 9 9 9 9 9</CellConfig>
			<!--The planning horizon [ms]. It should be equal orlarger than the Pilots cycle time-->
			<PlanningHorizon>250</PlanningHorizon>
			<!--The min. lookahead time [ms]-->
			<MinLookAhead>2000</MinLookAhead>
			<!--The max. lookahead time [ms]-->
			<MaxLookAhead>4000</MaxLookAhead>
			<!--Number of samples along the predicted trajectory (default: 10)-->
			<TrajectorySamples>10</TrajectorySamples>
			<!--How long is it allowed to have no valid velocity command-->
			<MaxNoCommandTime>30000</MaxNoCommandTime>
			<!--The objectives-->
			<Objectives>
				<if_exists file="${findpkg Pilot}/etc/${pathPlanner}.xml">
					<include file="${findpkg Pilot}/etc/${pathPlanner}.xml" />
				</if_exists>
				<else>
					<include file="${find ${pathPlanner}.xml}"/>
				</else>
				<item>
					<Objective class="mira::pilot::PathFollowObjective">
						 <HeadingSmoothAngle>10</HeadingSmoothAngle>
					</Objective>
				</item>
				<item>
					<Objective class="mira::pilot::ExploreObjective">
						<!--Maximum velocity for exploring-->
						<MaxExploreVelocity>0.5</MaxExploreVelocity>
						<!-- Maximum rotational velocity for in-place rotations -->
						<MaxInplaceRotationalVelocity>30</MaxInplaceRotationalVelocity>
					</Objective>
					<!--If true, the objective is disabled-->
					<Disabled>false</Disabled>
					<!--The weight for this objective-->
					<Weight>1.0</Weight>
				</item>
				<item>
					<Objective class="mira::pilot::MileageObjective"/>
					<!--If true, the objective is disabled-->
					<Disabled>false</Disabled>
					<!--The weight for this objective-->
					<Weight>1.0</Weight>
				</item>
				<item>
					<Objective class="mira::pilot::HeadingObjective">
						<!--Time until objective is dissatisfied with current progress-->
						<DissatisfactionTime>5000</DissatisfactionTime>
					</Objective>
					<!--If true, the objective is disabled-->
					<Disabled>false</Disabled>
					<!--The weight for this objective-->
					<Weight>1.0</Weight>
				</item>
				<item>
					<Objective class="mira::pilot::DirectionObjective">
						<!--Factor for weighting driving into the wrong direction-->
						<DistanceFactor>0.025</DistanceFactor>
						<!--Minimum costs for driving into wrong direction-->
						<MinWrongDirectionCost>0.01</MinWrongDirectionCost>
						<!--The additional costs that are caused by a wrong heading direction that does not point along the path to the goal, should be as small as possible-->
						<HeadingWeight>0.001</HeadingWeight>
						<!--Maximum distance we are allowed to drive into non preferred direction [m]-->
						<MaxWrongDistance>1.0</MaxWrongDistance>
						<!--Maximum age of path to be used for target direction computation-->
						<MaxPathAge>1000</MaxPathAge>
						<!--When goal is closer than MaxWrongDistance we avoid turning and instead take the shortest path (leads to driving into wrong direction when close to goal)-->
						<AvoidTurnNearGoal>true</AvoidTurnNearGoal>
					</Objective>
					<!--If true, the objective is disabled-->
					<Disabled>false</Disabled>
					<!--The weight for this objective-->
					<Weight>50.0</Weight>
				</item>
				<item>
					<Objective class="mira::pilot::DistanceObjective">
						<!--Max. distance in m that is used for the cost function. Distances > DistanceLimitForCosts are not taken into account-->
						<DistanceLimitForCosts>0</DistanceLimitForCosts>
						<!--Model for collision testing-->
						<CollisionTest>
							<!--Resolution of the collision map [m]-->
							<CellSize>0.02</CellSize>
							<!--Size of the collision LUT (360 deg is divided in #segments)-->
							<Segments>360</Segments>
							<!--Occupancy grid values above this threshold are counted as obstacles-->
							<ObstacleThreshold>140</ObstacleThreshold>
						</CollisionTest>
						<!--Maximum translational velocity if an obstacle violates the safety zone defined for the robot (if any)-->
						<MaxSafetyZoneTransVelocity>0.3</MaxSafetyZoneTransVelocity>
						<!--Maximum age of collision test map-->
						<MaxMapAge>1000</MaxMapAge>
						<!--How often is the debug map updated-->
						<DbgUpdateInterval>1000</DbgUpdateInterval>
					</Objective>
					<!--If true, the objective is disabled-->
					<Disabled>false</Disabled>
					<!--The weight for this objective-->
					<Weight>1.0</Weight>
				</item>
				<item>
					<Objective class="mira::pilot::SpeedObjective">
						<!--The name of the speed map channel-->
						<Map>SpeedMap</Map>
						<!--The allowed speed for 'black' regions in the map (in m/s)-->
						<LowerSpeed>0</LowerSpeed>
						<!--The allowed speed for 'white' regions in the map (in m/s)-->
						<UpperSpeed>1</UpperSpeed>
					</Objective>
					<!--If true, the objective is disabled-->
					<Disabled>false</Disabled>
					<!--The weight for this objective-->
					<Weight>1.0</Weight>
				</item>
				<item>
					<Objective class="mira::pilot::DockingObjective">
						<!--Desired velocity for docking (must be > 0)-->
						<Velocity>0.1</Velocity>
						<!--The weight that is used for reaching the desired docking velocity-->
						<VelocityWeight>0.2</VelocityWeight>
						<!--The weight that is used for reaching the desired docking position-->
						<DistanceWeight>0.0</DistanceWeight>
						<!--The weight that is used for angular deviations from the docking trajectory (needs to be small <= 0.001)-->
						<HeadingWeight>0.0</HeadingWeight>
						<!--The exponent for computing the costs depending on the distance from the alignment trajectory-->
						<TrajectoryCostPower>4</TrajectoryCostPower>
						<!--Multiplier for internal lookahead distance (<1: will result in a steeper alignment motion)-->
						<LookAhead>1.5</LookAhead>
						<!--Should we throw an exception if we miss the goal and pass the docking base line or should we continue driving forever-->
						<ThrowWhenMissed>true</ThrowWhenMissed>
					</Objective>
					<!--If true, the objective is disabled-->
					<Disabled>false</Disabled>
					<!--The weight for this objective-->
					<Weight>1.0</Weight>
				</item>
				<item>
					<Objective class="mira::pilot::RewindRecovery">
						<!--Length of the position history/path (path length in meter) to rewind-->
						<CommandHistoryLength>1.5</CommandHistoryLength>
						<!--Tolerance for finding the next pose on the path-->
						<PathLookaheadTolerance X="0.1" Y="0.1" Phi="5.0" />
					</Objective>
					<!--If true, the objective is disabled-->
					<Disabled>false</Disabled>
					<!--The weight for this objective-->
					<Weight>1.0</Weight>
				</item>
				<item>
					<Objective class="mira::pilot::RotateObjective">
						<MaxZeroChosenDuration>60000</MaxZeroChosenDuration>
					</Objective>
					<!--If true, the objective is disabled-->
					<Disabled>false</Disabled>
					<!--The weight for this objective-->
					<Weight>1.0</Weight>
				</item>
			</Objectives>
		</Planner>
		<RecoveryStrategies>
			<key>1</key>
			<item>
				<SubTasks>
					<item class="mira::pilot::RewindRecoveryTask" />
				</SubTasks>
			</item>
		</RecoveryStrategies>
	</unit>
</root>
